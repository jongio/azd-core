// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// Package security provides security utilities for path validation, input sanitization,
// and protection against common vulnerabilities like path traversal attacks.
package security

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
)

var (
	// ErrInvalidPath indicates a path contains invalid characters or patterns.
	ErrInvalidPath = errors.New("invalid path")
	// ErrPathTraversal indicates a path traversal attack attempt.
	ErrPathTraversal = errors.New("path traversal detected")
	// ErrInvalidServiceName indicates an invalid service name.
	ErrInvalidServiceName = errors.New("invalid service name")

	// serviceNamePattern validates service names - alphanumeric start, then alphanumeric, underscore, hyphen, or dot.
	// Max 63 characters to align with DNS label limits and container naming conventions.
	serviceNamePattern = regexp.MustCompile(`^[a-zA-Z0-9][a-zA-Z0-9._-]{0,62}$`)
)

// ValidatePath checks if a path is safe to use.
// It prevents path traversal attacks, symbolic link attacks, and validates the path is within allowed bounds.
func ValidatePath(path string) error {
	if path == "" {
		return fmt.Errorf("%w: empty path", ErrInvalidPath)
	}

	// Check for path traversal attempts before resolving
	if strings.Contains(path, "..") {
		return fmt.Errorf("%w: path contains parent directory reference", ErrPathTraversal)
	}

	// Convert to absolute path
	absPath, err := filepath.Abs(path)
	if err != nil {
		return fmt.Errorf("%w: cannot resolve path: %w", ErrInvalidPath, err)
	}

	// Clean the path
	cleanPath := filepath.Clean(absPath)

	// After cleaning, check again for ..
	if strings.Contains(cleanPath, "..") {
		return fmt.Errorf("%w: cleaned path contains parent directory reference", ErrPathTraversal)
	}

	// Resolve symbolic links to detect link-based attacks
	// This prevents attackers from using symlinks to escape allowed directories
	resolvedPath, err := filepath.EvalSymlinks(cleanPath)
	if err != nil {
		// If the path doesn't exist yet, that's okay - we're validating the path structure
		if !os.IsNotExist(err) {
			return fmt.Errorf("%w: cannot resolve symbolic links: %w", ErrInvalidPath, err)
		}
		// Path doesn't exist, use cleaned path for validation
		resolvedPath = cleanPath
	}

	// Verify resolved path doesn't contain ..
	if strings.Contains(resolvedPath, "..") {
		return fmt.Errorf("%w: resolved path contains parent directory reference", ErrPathTraversal)
	}

	return nil
}

// ValidateServiceName validates that a service name is safe and well-formed.
// Service names must:
// - Start with an alphanumeric character
// - Contain only alphanumeric characters, underscores, hyphens, or dots
// - Be at most 63 characters (DNS label limit)
// - Not contain path traversal sequences
//
// If allowEmpty is true, empty strings are accepted (for optional parameters).
func ValidateServiceName(name string, allowEmpty bool) error {
	if name == "" {
		if allowEmpty {
			return nil
		}
		return fmt.Errorf("%w: service name cannot be empty", ErrInvalidServiceName)
	}

	if len(name) > 63 {
		return fmt.Errorf("%w: exceeds maximum length of 63 characters", ErrInvalidServiceName)
	}

	if !serviceNamePattern.MatchString(name) {
		return fmt.Errorf("%w: must start with alphanumeric and contain only alphanumeric, underscore, hyphen, or dot", ErrInvalidServiceName)
	}

	// Extra check for path traversal attempts
	if strings.Contains(name, "..") || strings.Contains(name, "/") || strings.Contains(name, "\\") {
		return fmt.Errorf("%w: contains invalid path characters", ErrInvalidServiceName)
	}

	return nil
}

// ValidatePackageManager checks if the package manager name is allowed.
func ValidatePackageManager(pm string) error {
	allowed := map[string]bool{
		"npm":    true,
		"pnpm":   true,
		"yarn":   true,
		"pip":    true,
		"poetry": true,
		"uv":     true,
		"dotnet": true,
	}

	if !allowed[pm] {
		return fmt.Errorf("invalid package manager: %s", pm)
	}

	return nil
}

// SanitizeScriptName ensures a script name doesn't contain shell metacharacters.
func SanitizeScriptName(name string) error {
	// Disallow shell metacharacters
	dangerous := []string{";", "&", "|", ">", "<", "`", "$", "(", ")", "{", "}", "[", "]", "\n", "\r", "\"", "'", "\\", "#"}

	for _, char := range dangerous {
		if strings.Contains(name, char) {
			return fmt.Errorf("script name contains dangerous character: %s", char)
		}
	}

	return nil
}

// IsContainerEnvironment detects if the code is running in a containerized environment.
// It checks for:
// - GitHub Codespaces (CODESPACES=true)
// - VS Code Dev Containers (REMOTE_CONTAINERS=true)
// - Docker containers (/.dockerenv file exists)
// - Kubernetes pods (KUBERNETES_SERVICE_HOST set)
func IsContainerEnvironment() bool {
	// Check for GitHub Codespaces
	if os.Getenv("CODESPACES") == "true" {
		return true
	}

	// Check for VS Code Dev Containers
	if os.Getenv("REMOTE_CONTAINERS") == "true" {
		return true
	}

	// Check for Kubernetes
	if os.Getenv("KUBERNETES_SERVICE_HOST") != "" {
		return true
	}

	// Check for Docker container (/.dockerenv file exists)
	if _, err := os.Stat("/.dockerenv"); err == nil {
		return true
	}

	return false
}

// ErrInsecureFilePermissions indicates a file has insecure (world-writable) permissions.
var ErrInsecureFilePermissions = errors.New("insecure file permissions")

// ValidatePathWithinBases validates a path and ensures it's within one of the allowed base directories.
// Returns the resolved absolute path or an error.
// If no allowedBases are provided, it just validates the path structure.
func ValidatePathWithinBases(path string, allowedBases ...string) (string, error) {
	if err := ValidatePath(path); err != nil {
		return "", err
	}

	absPath, err := filepath.Abs(path)
	if err != nil {
		return "", fmt.Errorf("%w: cannot resolve path: %w", ErrInvalidPath, err)
	}
	absPath = filepath.Clean(absPath)

	// Resolve symlinks
	realPath, err := filepath.EvalSymlinks(absPath)
	if err != nil {
		if !os.IsNotExist(err) {
			return "", fmt.Errorf("%w: cannot resolve symbolic links: %w", ErrInvalidPath, err)
		}
		realPath = absPath
	}

	if len(allowedBases) > 0 {
		allowed := false
		for _, base := range allowedBases {
			absBase, err := filepath.Abs(base)
			if err != nil {
				continue
			}
			absBase = filepath.Clean(absBase)

			// Resolve symlinks on base directories for consistent comparison
			realBase, err := filepath.EvalSymlinks(absBase)
			if err != nil {
				if !os.IsNotExist(err) {
					continue // skip bases we can't resolve
				}
				realBase = absBase
			}

			if strings.HasPrefix(realPath, realBase+string(filepath.Separator)) || realPath == realBase {
				allowed = true
				break
			}
		}
		if !allowed {
			return "", fmt.Errorf("%w: path is outside allowed directories", ErrPathTraversal)
		}
	}

	return realPath, nil
}

// ValidateFilePermissions checks if a file has secure permissions.
// On Unix systems, it ensures the file is not world-writable.
// On Windows, this check is skipped as Windows uses ACLs differently.
// If the file is world-writable on non-Windows platforms, this returns
// ErrInsecureFilePermissions. Callers may translate that into a user
// visible warning when running inside container environments.
func ValidateFilePermissions(path string) error {
	// Skip permission check on Windows as it uses ACLs
	if runtime.GOOS == "windows" {
		return nil
	}

	info, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("failed to stat file: %w", err)
	}

	// Check if file is world-writable (insecure)
	if info.Mode().Perm()&0o022 != 0 {
		// Signal insecure permissions to caller using sentinel error
		return ErrInsecureFilePermissions
	}

	return nil
}
